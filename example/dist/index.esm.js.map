{"version":3,"file":"index.esm.js","sources":["../src/types.ts","../node_modules/path-browserify/index.js","../src/MemoryCache.ts","../src/TypeDefinitionResolver.ts"],"sourcesContent":["export interface Package {\n  name: string;\n  version: string;\n}\n\nexport interface PackageJson {\n  name: string;\n  types?: string;\n  typings?: string;\n  typeVersions?: Record<string, string[] | Record<string, string[]>>;\n  exports?: Record<string, any>;\n}\n\nexport enum TypeDefinitionSource {\n  PACKAGE_JSON = 'package.json',\n  BACKEND = 'backend',\n  DEFAULT = 'default',\n  REFERENCE = 'reference',\n  IMPORT = 'import'\n}\n\nexport interface TypeDefinitionResult {\n  content: string;\n  filePath: string;\n  source: TypeDefinitionSource;\n}\n\nexport interface TypesResolveOptions {\n  /** 是否启用缓存 */\n  cacheEnabled?: boolean;\n  /** node_modules 的基础路径 */\n  baseUrl?: string;\n  /** 类型定义文件路径前缀 */\n  pathPrefix?: string;\n}\n\nexport interface CacheEntry {\n  results: TypeDefinitionResult[];\n  mainTypePath?: string;\n  fullyResolved: boolean;\n} ","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","import { TypeDefinitionResult, CacheEntry } from './types';\n\n/**\n * Memory cache for storing type definitions\n */\nexport class MemoryCache {\n  private prefix: string;\n  private cache: Map<string, CacheEntry>;\n\n  constructor(prefix: string = 'typing-cache') {\n    this.prefix = prefix;\n    this.cache = new Map();\n  }\n\n  /**\n   * Get cache key for package\n   * @param packageName Package name\n   * @returns Cache key\n   */\n  private getKey(packageName: string): string {\n    return `${this.prefix}:${packageName}`;\n  }\n\n  /**\n   * Get cached entry for package\n   * @param packageName Package name\n   * @returns Cached entry or null\n   */\n  getItem(packageName: string): CacheEntry | null {\n    try {\n      const key = this.getKey(packageName);\n      return this.cache.get(key) || null;\n    } catch (error) {\n      console.error('Error reading from cache:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Set cache entry for package\n   * @param packageName Package name\n   * @param results Type definition results\n   * @param mainTypePath Main type file path\n   */\n  set(\n    packageName: string,\n    results: TypeDefinitionResult[],\n    mainTypePath?: string\n  ): void {\n    try {\n      const key = this.getKey(packageName);\n      const entry: CacheEntry = {\n        results,\n        mainTypePath,\n        fullyResolved: true\n      };\n      this.cache.set(key, entry);\n    } catch (error) {\n      console.error('Error writing to cache:', error);\n    }\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clear(): void {\n    try {\n      this.cache.clear();\n    } catch (error) {\n      console.error('Error clearing cache:', error);\n    }\n  }\n} ","import { PackageJson, TypeDefinitionResult, TypeDefinitionSource, TypesResolveOptions } from './types';\nimport pathBrowserify from 'path-browserify';\nimport { MemoryCache } from './MemoryCache';\n\nexport function normalizePath(path: string): string {\n  return path.replace(/\\\\/g, '/');\n}\n\nexport class TypeDefinitionResolver {\n  private cache: MemoryCache;\n  private options: Required<TypesResolveOptions>;\n  /** Hash set to prevent circular references */\n  private processedFiles: Set<string>;\n\n  constructor(options: TypesResolveOptions = {}) {\n    this.options = {\n      cacheEnabled: true,\n      baseUrl: '/node_modules',\n      pathPrefix: '',\n      ...options\n    };\n    this.cache = new MemoryCache('typing-cache');\n    this.processedFiles = new Set();\n  }\n\n  private getFilePath(packageName: string, relativePath: string): string {\n    // 先处理包内路径\n    const packagePath = pathBrowserify.join(packageName, relativePath);\n    // 直接拼接 pathPrefix，不使用 pathBrowserify.join\n    return normalizePath(`${this.options.pathPrefix}${packagePath}`);\n  }\n\n  /**\n   * Resolve type definitions for a package\n   * @param packageName Package name\n   * @returns Type definition results\n   */\n  async resolveTypeDefinition(packageName: string): Promise<TypeDefinitionResult[]> {\n    // Reset processed files set\n    this.processedFiles.clear();\n\n    if (this.options.cacheEnabled) {\n      const cached = this.cache.getItem(packageName);\n      if (cached && cached.fullyResolved) {\n        return cached.results;\n      }\n    }\n\n    try {\n      const results: TypeDefinitionResult[] = [];\n\n      // 确定要查找的包名\n      let typesPackageName: string;\n      if (packageName.startsWith('@types/')) {\n        // 如果已经是 @types 包,直接使用\n        typesPackageName = packageName;\n      } else {\n        // 否则转换为 @types 包名\n        typesPackageName = `@types/${packageName.replace('@', '').replace('/', '__')}`;\n        \n        // 检查 @types 包是否已经缓存\n        if (this.options.cacheEnabled) {\n          const typesCache = this.cache.getItem(typesPackageName);\n          if (typesCache && typesCache.fullyResolved) {\n            return typesCache.results;\n          }\n        }\n      }\n\n      try {\n        const typesPackageJson = await this.fetchPackageJson(typesPackageName);\n        results.push({\n          content: JSON.stringify(typesPackageJson),\n          filePath: this.getFilePath(typesPackageName, 'package.json'),\n          source: TypeDefinitionSource.PACKAGE_JSON\n        });\n\n        const typesPaths = await this.resolveTypePaths(typesPackageJson);\n        for (const typePath of typesPaths) {\n          const typeResults = await this.resolveTypeFiles(typesPackageName, typePath);\n          if (typeResults.length > 0) {\n            results.push(...typeResults);\n          }\n        }\n\n        // 如果找到了 @types 包的类型定义\n        if (results.length > 1) {\n          if (this.options.cacheEnabled) {\n            // 同时缓存原始包名和 @types 包名的结果\n            this.cache.set(packageName, results);\n            if (typesPackageName !== packageName) {\n              this.cache.set(typesPackageName, results);\n            }\n          }\n          return results;\n        }\n      } catch (error) {\n        // 忽略错误,继续尝试从原始包获取类型\n        console.debug(`No @types package found for ${packageName}, trying original package`);\n      }\n\n      const packageJson = await this.fetchPackageJson(packageName);\n      results.push({\n        content: JSON.stringify(packageJson),\n        filePath: this.getFilePath(packageName, 'package.json'),\n        source: TypeDefinitionSource.PACKAGE_JSON\n      });\n\n      const typePaths = await this.resolveTypePaths(packageJson);\n      let mainTypePath: string | undefined;\n\n      for (const typePath of typePaths) {\n        const typeResults = await this.resolveTypeFiles(packageName, typePath);\n        if (typeResults.length > 0) {\n          results.push(...typeResults);\n          // Record main type file path\n          if (!mainTypePath && typePath.endsWith('index.d.ts')) {\n            mainTypePath = typePath;\n          }\n        }\n      }\n\n      // If no type definitions found, use default any type\n      if (results.length === 0) {\n        results.push(this.generateDefaultTypings(packageName));\n      }\n\n      if (this.options.cacheEnabled) {\n        this.cache.set(packageName, results, mainTypePath);\n      }\n\n      return results;\n    } catch (error) {\n      console.error(`Error resolving types for ${packageName}:`, error);\n      // Return default type on error\n      return [this.generateDefaultTypings(packageName)];\n    }\n  }\n\n  /**\n   * Generate default any type definition\n   * @param packageName Package name\n   * @returns Default type definition result\n   */\n  private generateDefaultTypings(packageName: string): TypeDefinitionResult {\n    const content = this.generateDefaultTypeDefinition(packageName);\n    return {\n      content,\n      filePath: this.getFilePath(packageName, 'index.d.ts'),\n      source: TypeDefinitionSource.DEFAULT\n    };\n  }\n\n  /**\n   * Generate default type definition content\n   * @param packageName Package name\n   * @returns Type definition content\n   */\n  private generateDefaultTypeDefinition(packageName: string): string {\n    return `\n/**\n * Default type definition for ${packageName}\n * This is an auto-generated fallback definition.\n */\n\ndeclare module '${packageName}' {\n    const content: any;\n    export default content;\n    export * from '${packageName}/*';\n}\n\ndeclare module '${packageName}/*' {\n    const content: any;\n    export default content;\n    export * as namespace ${packageName};\n}\n`;\n  }\n\n  /**\n   * Fetch package.json content\n   * @param packageName Package name\n   * @returns package.json content\n   */\n  private async fetchPackageJson(packageName: string): Promise<PackageJson> {\n    const response = await fetch(`${this.options.baseUrl}/${packageName}/package.json`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch package.json for ${packageName}`);\n    }\n    return response.json();\n  }\n\n  /**\n   * Resolve all possible type definition file paths\n   * @param packageJson package.json content\n   * @returns Array of type definition file paths\n   */\n  private async resolveTypePaths(packageJson: PackageJson): Promise<string[]> {\n    const paths: Set<string> = new Set();\n\n    // 1. Check typeVersions\n    if (packageJson.typeVersions) {\n      for (const version in packageJson.typeVersions) {\n        const typeVersionPaths = packageJson.typeVersions[version];\n        if (Array.isArray(typeVersionPaths)) {\n          typeVersionPaths.forEach(path => {\n            if (path.includes('*')) {\n              // Handle wildcards for packages like rxjs\n              const basePath = path.replace('*', '');\n              // Add main entry\n              paths.add(pathBrowserify.join(basePath, 'index.d.ts'));\n              // Add all possible submodules\n              const subModules = ['internal', 'ajax', 'operators', 'testing', 'webSocket', 'fetch'];\n              for (const module of subModules) {\n                paths.add(pathBrowserify.join(basePath, module, 'index.d.ts'));\n              }\n            } else {\n              paths.add(path);\n            }\n          });\n        } else if (typeof typeVersionPaths === 'object') {\n          // Handle mapped type versions\n          Object.values(typeVersionPaths).forEach(pathArray => {\n            if (Array.isArray(pathArray)) {\n              pathArray.forEach(path => paths.add(path));\n            }\n          });\n        }\n      }\n    }\n\n    // 2. Check exports.types\n    if (packageJson.exports) {\n      const addExportTypes = (obj: Record<string, any>, prefix: string = '') => {\n        for (const [key, value] of Object.entries(obj)) {\n          if (value && typeof value === 'object') {\n            if ('types' in value && typeof value.types === 'string') {\n              paths.add(value.types);\n            }\n            if (!key.startsWith('.')) {\n              addExportTypes(value, `${prefix}${key}/`);\n            } else {\n              addExportTypes(value, prefix);\n            }\n          } else if (typeof value === 'string' && key === 'types') {\n            paths.add(value);\n          }\n        }\n      };\n      addExportTypes(packageJson.exports);\n    }\n\n    // 3. Check traditional type fields\n    if (packageJson.types) {\n      paths.add(packageJson.types);\n    }\n    if (packageJson.typings) {\n      paths.add(packageJson.typings);\n    }\n\n    // 4. Default paths\n    paths.add('index.d.ts');\n    paths.add('dist/index.d.ts');\n    paths.add('dist/types/index.d.ts');\n\n    return Array.from(paths);\n  }\n\n  /**\n   * Normalize relative path\n   * @param currentDir Current directory\n   * @param relativePath Relative path\n   * @returns Normalized path\n   */\n  private normalizeRelativePath(currentDir: string, relativePath: string): string {\n    return pathBrowserify.normalize(pathBrowserify.join(currentDir, relativePath));\n  }\n\n  /**\n   * Resolve type file contents\n   * @param packageName Package name\n   * @param typesPath Type file path\n   * @returns Type definition results array\n   */\n  private async resolveTypeFiles(packageName: string, typesPath: string): Promise<TypeDefinitionResult[]> {\n    const results: TypeDefinitionResult[] = [];\n    const baseUrl = `${this.options.baseUrl}/${packageName}`;\n    const filePath = pathBrowserify.normalize(pathBrowserify.join(baseUrl, typesPath));\n    \n    // Check if file has been processed\n    if (this.processedFiles.has(filePath)) {\n      return [];\n    }\n    this.processedFiles.add(filePath);\n    \n    try {\n      const response = await fetch(filePath);\n      if (!response.ok) {\n        return [];\n      }\n      \n      const content = await response.text();\n      results.push({\n        content,\n        filePath: this.getFilePath(packageName, typesPath),\n        source: TypeDefinitionSource.BACKEND\n      });\n\n      // Resolve referenced type files\n      await this.resolveReferences(content, packageName, typesPath, results);\n      \n      // Resolve import statements\n      await this.resolveImports(content, packageName, typesPath, results);\n      \n    } catch (error) {\n      console.error(`Error resolving type files for ${packageName}:`, error);\n    }\n\n    return results;\n  }\n\n  /**\n   * Resolve type references in file\n   * @param content File content\n   * @param packageName Package name\n   * @param currentPath Current file path\n   * @param results Results array\n   */\n  private async resolveReferences(\n    content: string,\n    packageName: string,\n    currentPath: string,\n    results: TypeDefinitionResult[]\n  ): Promise<void> {\n    const referenceRegex = /\\/\\/\\/\\s*<reference\\s+path=\"([^\"]+)\"\\s*\\/>/g;\n    const matches = content.matchAll(referenceRegex);\n    const currentDir = pathBrowserify.dirname(currentPath);\n\n    for (const match of matches) {\n      const referencePath = match[1];\n      const baseUrl = `${this.options.baseUrl}/${packageName}`;\n      const relativePath = this.normalizeRelativePath(currentDir, referencePath);\n      const fullPath = pathBrowserify.normalize(pathBrowserify.join(baseUrl, relativePath));\n\n      // Check if file has been processed\n      if (this.processedFiles.has(fullPath)) {\n        continue;\n      }\n      this.processedFiles.add(fullPath);\n\n      try {\n        const response = await fetch(fullPath);\n        if (response.ok) {\n          const referenceContent = await response.text();\n          results.push({\n            content: referenceContent,\n            filePath: this.getFilePath(packageName, relativePath),\n            source: TypeDefinitionSource.REFERENCE\n          });\n\n          // Recursively resolve references in referenced file\n          await this.resolveReferences(referenceContent, packageName, relativePath, results);\n          await this.resolveImports(referenceContent, packageName, relativePath, results);\n        }\n      } catch (error) {\n        console.error(`Error resolving reference ${referencePath}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Resolve import statements in file\n   * @param content File content\n   * @param packageName Package name\n   * @param currentPath Current file path\n   * @param results Results array\n   */\n  private async resolveImports(\n    content: string,\n    packageName: string,\n    currentPath: string,\n    results: TypeDefinitionResult[]\n  ): Promise<void> {\n    const importRegex = /(?:import|export)\\s+(?:{[^}]*}|\\*\\s+as\\s+[^;]+)?\\s*(?:from\\s+)?['\"]([^'\"]+)['\"]/g;\n    const matches = content.matchAll(importRegex);\n    const currentDir = pathBrowserify.dirname(currentPath);\n\n    for (const match of matches) {\n      const importPath = match[1];\n      // Handle relative and package internal paths\n      if (importPath.startsWith('.') || importPath.startsWith(packageName)) {\n        const baseUrl = `${this.options.baseUrl}/${packageName}`;\n        const resolvedPath = importPath.startsWith('.')\n          ? this.normalizeRelativePath(currentDir, importPath)\n          : pathBrowserify.normalize(importPath.replace(packageName, ''));\n        \n        const relativeTypePath = resolvedPath.endsWith('.d.ts') \n          ? resolvedPath \n          : resolvedPath.endsWith('.ts')\n            ? resolvedPath.replace(/\\.ts$/, '.d.ts')\n            : `${resolvedPath}.d.ts`;\n\n        const fullPath = pathBrowserify.normalize(pathBrowserify.join(baseUrl, relativeTypePath));\n\n        // Check if file has been processed\n        if (this.processedFiles.has(fullPath)) {\n          continue;\n        }\n        this.processedFiles.add(fullPath);\n\n        try {\n          const response = await fetch(fullPath);\n          if (response.ok) {\n            const importContent = await response.text();\n            results.push({\n              content: importContent,\n              filePath: this.getFilePath(packageName, relativeTypePath),\n              source: TypeDefinitionSource.IMPORT\n            });\n\n            // Recursively resolve references in imported file\n            await this.resolveReferences(importContent, packageName, relativeTypePath, results);\n            await this.resolveImports(importContent, packageName, relativeTypePath, results);\n          } else {\n            // Try looking in dist/types directory\n            const altPath = pathBrowserify.normalize(pathBrowserify.join(baseUrl, 'dist/types', relativeTypePath));\n            const altResponse = await fetch(altPath);\n            if (altResponse.ok) {\n              const importContent = await altResponse.text();\n              results.push({\n                content: importContent,\n                filePath: this.getFilePath(packageName, `dist/types/${relativeTypePath}`),\n                source: TypeDefinitionSource.IMPORT\n              });\n\n              await this.resolveReferences(importContent, packageName, `dist/types/${relativeTypePath}`, results);\n              await this.resolveImports(importContent, packageName, `dist/types/${relativeTypePath}`, results);\n            }\n          }\n        } catch (error) {\n          console.error(`Error resolving import ${importPath}:`, error);\n        }\n      }\n    }\n  }\n} "],"names":["pathBrowserify"],"mappings":"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","x_google_ignoreList":[1]}