{"version":3,"file":"index.umd.js","sources":["../src/types.ts","../node_modules/path-browserify/index.js","../src/MemoryCache.ts","../src/TypeDefinitionResolver.ts"],"sourcesContent":["export interface Package {\n  name: string;\n  version: string;\n}\n\nexport interface PackageJson {\n  name: string;\n  types?: string;\n  typings?: string;\n  typeVersions?: Record<string, string[] | Record<string, string[]>>;\n  exports?: Record<string, any>;\n}\n\nexport enum TypeDefinitionSource {\n  PACKAGE_JSON = 'package.json',\n  BACKEND = 'backend',\n  DEFAULT = 'default',\n  REFERENCE = 'reference',\n  IMPORT = 'import'\n}\n\nexport interface TypeDefinitionResult {\n  content: string;\n  filePath: string;\n  source: TypeDefinitionSource;\n}\n\nexport interface TypesResolveOptions {\n  /** 是否启用缓存 */\n  cacheEnabled?: boolean;\n  /** node_modules 的基础路径 */\n  baseUrl?: string;\n  /** 类型定义文件路径前缀 */\n  pathPrefix?: string;\n}\n\nexport interface CacheEntry {\n  results: TypeDefinitionResult[];\n  mainTypePath?: string;\n  fullyResolved: boolean;\n} ","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","import { TypeDefinitionResult, CacheEntry } from './types';\n\n/**\n * Memory cache for storing type definitions\n */\nexport class MemoryCache {\n  private prefix: string;\n  private cache: Map<string, CacheEntry>;\n\n  constructor(prefix: string = 'typing-cache') {\n    this.prefix = prefix;\n    this.cache = new Map();\n  }\n\n  /**\n   * Get cache key for package\n   * @param packageName Package name\n   * @returns Cache key\n   */\n  private getKey(packageName: string): string {\n    return `${this.prefix}:${packageName}`;\n  }\n\n  /**\n   * Get cached entry for package\n   * @param packageName Package name\n   * @returns Cached entry or null\n   */\n  getItem(packageName: string): CacheEntry | null {\n    try {\n      const key = this.getKey(packageName);\n      return this.cache.get(key) || null;\n    } catch (error) {\n      console.error('Error reading from cache:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Set cache entry for package\n   * @param packageName Package name\n   * @param results Type definition results\n   * @param mainTypePath Main type file path\n   */\n  set(\n    packageName: string,\n    results: TypeDefinitionResult[],\n    mainTypePath?: string\n  ): void {\n    try {\n      const key = this.getKey(packageName);\n      const entry: CacheEntry = {\n        results,\n        mainTypePath,\n        fullyResolved: true\n      };\n      this.cache.set(key, entry);\n    } catch (error) {\n      console.error('Error writing to cache:', error);\n    }\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clear(): void {\n    try {\n      this.cache.clear();\n    } catch (error) {\n      console.error('Error clearing cache:', error);\n    }\n  }\n} ","import { PackageJson, TypeDefinitionResult, TypeDefinitionSource, TypesResolveOptions } from './types';\nimport pathBrowserify from 'path-browserify';\nimport { MemoryCache } from './MemoryCache';\n\nexport function normalizePath(path: string): string {\n  return path.replace(/\\\\/g, '/');\n}\n\nexport class TypeDefinitionResolver {\n  private cache: MemoryCache;\n  private options: Required<TypesResolveOptions>;\n  /** Hash set to prevent circular references */\n  private processedFiles: Set<string>;\n\n  constructor(options: TypesResolveOptions = {}) {\n    this.options = {\n      cacheEnabled: true,\n      baseUrl: '/node_modules',\n      pathPrefix: '',\n      ...options\n    };\n    this.cache = new MemoryCache('typing-cache');\n    this.processedFiles = new Set();\n  }\n\n  private getFilePath(packageName: string, relativePath: string): string {\n    // 先处理包内路径\n    const packagePath = pathBrowserify.join(packageName, relativePath);\n    // 直接拼接 pathPrefix，不使用 pathBrowserify.join\n    return normalizePath(`${this.options.pathPrefix}${packagePath}`);\n  }\n\n  /**\n   * Resolve type definitions for a package\n   * @param packageName Package name\n   * @returns Type definition results\n   */\n  async resolveTypeDefinition(packageName: string): Promise<TypeDefinitionResult[]> {\n    // Reset processed files set\n    this.processedFiles.clear();\n\n    if (this.options.cacheEnabled) {\n      const cached = this.cache.getItem(packageName);\n      if (cached && cached.fullyResolved) {\n        return cached.results;\n      }\n    }\n\n    try {\n      const results: TypeDefinitionResult[] = [];\n\n      // 确定要查找的包名\n      let typesPackageName: string;\n      if (packageName.startsWith('@types/')) {\n        // 如果已经是 @types 包,直接使用\n        typesPackageName = packageName;\n      } else {\n        // 否则转换为 @types 包名\n        typesPackageName = `@types/${packageName.replace('@', '').replace('/', '__')}`;\n        \n        // 检查 @types 包是否已经缓存\n        if (this.options.cacheEnabled) {\n          const typesCache = this.cache.getItem(typesPackageName);\n          if (typesCache && typesCache.fullyResolved) {\n            return typesCache.results;\n          }\n        }\n      }\n\n      try {\n        const typesPackageJson = await this.fetchPackageJson(typesPackageName);\n        results.push({\n          content: JSON.stringify(typesPackageJson),\n          filePath: this.getFilePath(typesPackageName, 'package.json'),\n          source: TypeDefinitionSource.PACKAGE_JSON\n        });\n\n        const typesPaths = await this.resolveTypePaths(typesPackageJson);\n        for (const typePath of typesPaths) {\n          const typeResults = await this.resolveTypeFiles(typesPackageName, typePath);\n          if (typeResults.length > 0) {\n            results.push(...typeResults);\n          }\n        }\n\n        // 如果找到了 @types 包的类型定义\n        if (results.length > 1) {\n          if (this.options.cacheEnabled) {\n            // 同时缓存原始包名和 @types 包名的结果\n            this.cache.set(packageName, results);\n            if (typesPackageName !== packageName) {\n              this.cache.set(typesPackageName, results);\n            }\n          }\n          return results;\n        }\n      } catch (error) {\n        // 忽略错误,继续尝试从原始包获取类型\n        console.debug(`No @types package found for ${packageName}, trying original package`);\n      }\n\n      const packageJson = await this.fetchPackageJson(packageName);\n      results.push({\n        content: JSON.stringify(packageJson),\n        filePath: this.getFilePath(packageName, 'package.json'),\n        source: TypeDefinitionSource.PACKAGE_JSON\n      });\n\n      const typePaths = await this.resolveTypePaths(packageJson);\n      let mainTypePath: string | undefined;\n\n      for (const typePath of typePaths) {\n        const typeResults = await this.resolveTypeFiles(packageName, typePath);\n        if (typeResults.length > 0) {\n          results.push(...typeResults);\n          // Record main type file path\n          if (!mainTypePath && typePath.endsWith('index.d.ts')) {\n            mainTypePath = typePath;\n          }\n        }\n      }\n\n      // If no type definitions found, use default any type\n      if (results.length === 0) {\n        results.push(this.generateDefaultTypings(packageName));\n      }\n\n      if (this.options.cacheEnabled) {\n        this.cache.set(packageName, results, mainTypePath);\n      }\n\n      return results;\n    } catch (error) {\n      console.error(`Error resolving types for ${packageName}:`, error);\n      // Return default type on error\n      return [this.generateDefaultTypings(packageName)];\n    }\n  }\n\n  /**\n   * Generate default any type definition\n   * @param packageName Package name\n   * @returns Default type definition result\n   */\n  private generateDefaultTypings(packageName: string): TypeDefinitionResult {\n    const content = this.generateDefaultTypeDefinition(packageName);\n    return {\n      content,\n      filePath: this.getFilePath(packageName, 'index.d.ts'),\n      source: TypeDefinitionSource.DEFAULT\n    };\n  }\n\n  /**\n   * Generate default type definition content\n   * @param packageName Package name\n   * @returns Type definition content\n   */\n  private generateDefaultTypeDefinition(packageName: string): string {\n    return `\n/**\n * Default type definition for ${packageName}\n * This is an auto-generated fallback definition.\n */\n\ndeclare module '${packageName}' {\n    const content: any;\n    export default content;\n    export * from '${packageName}/*';\n}\n\ndeclare module '${packageName}/*' {\n    const content: any;\n    export default content;\n    export * as namespace ${packageName};\n}\n`;\n  }\n\n  /**\n   * Fetch package.json content\n   * @param packageName Package name\n   * @returns package.json content\n   */\n  private async fetchPackageJson(packageName: string): Promise<PackageJson> {\n    const response = await fetch(`${this.options.baseUrl}/${packageName}/package.json`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch package.json for ${packageName}`);\n    }\n    return response.json();\n  }\n\n  /**\n   * Resolve all possible type definition file paths\n   * @param packageJson package.json content\n   * @returns Array of type definition file paths\n   */\n  private async resolveTypePaths(packageJson: PackageJson): Promise<string[]> {\n    const paths: Set<string> = new Set();\n\n    // 1. Check typeVersions\n    if (packageJson.typeVersions) {\n      for (const version in packageJson.typeVersions) {\n        const typeVersionPaths = packageJson.typeVersions[version];\n        if (Array.isArray(typeVersionPaths)) {\n          typeVersionPaths.forEach(path => {\n            if (path.includes('*')) {\n              // Handle wildcards for packages like rxjs\n              const basePath = path.replace('*', '');\n              // Add main entry\n              paths.add(pathBrowserify.join(basePath, 'index.d.ts'));\n              // Add all possible submodules\n              const subModules = ['internal', 'ajax', 'operators', 'testing', 'webSocket', 'fetch'];\n              for (const module of subModules) {\n                paths.add(pathBrowserify.join(basePath, module, 'index.d.ts'));\n              }\n            } else {\n              paths.add(path);\n            }\n          });\n        } else if (typeof typeVersionPaths === 'object') {\n          // Handle mapped type versions\n          Object.values(typeVersionPaths).forEach(pathArray => {\n            if (Array.isArray(pathArray)) {\n              pathArray.forEach(path => paths.add(path));\n            }\n          });\n        }\n      }\n    }\n\n    // 2. Check exports.types\n    if (packageJson.exports) {\n      const addExportTypes = (obj: Record<string, any>, prefix: string = '') => {\n        for (const [key, value] of Object.entries(obj)) {\n          if (value && typeof value === 'object') {\n            if ('types' in value && typeof value.types === 'string') {\n              paths.add(value.types);\n            }\n            if (!key.startsWith('.')) {\n              addExportTypes(value, `${prefix}${key}/`);\n            } else {\n              addExportTypes(value, prefix);\n            }\n          } else if (typeof value === 'string' && key === 'types') {\n            paths.add(value);\n          }\n        }\n      };\n      addExportTypes(packageJson.exports);\n    }\n\n    // 3. Check traditional type fields\n    if (packageJson.types) {\n      paths.add(packageJson.types);\n    }\n    if (packageJson.typings) {\n      paths.add(packageJson.typings);\n    }\n\n    // 4. Default paths\n    paths.add('index.d.ts');\n    paths.add('dist/index.d.ts');\n    paths.add('dist/types/index.d.ts');\n\n    return Array.from(paths);\n  }\n\n  /**\n   * Normalize relative path\n   * @param currentDir Current directory\n   * @param relativePath Relative path\n   * @returns Normalized path\n   */\n  private normalizeRelativePath(currentDir: string, relativePath: string): string {\n    return pathBrowserify.normalize(pathBrowserify.join(currentDir, relativePath));\n  }\n\n  /**\n   * Resolve type file contents\n   * @param packageName Package name\n   * @param typesPath Type file path\n   * @returns Type definition results array\n   */\n  private async resolveTypeFiles(packageName: string, typesPath: string): Promise<TypeDefinitionResult[]> {\n    const results: TypeDefinitionResult[] = [];\n    const baseUrl = `${this.options.baseUrl}/${packageName}`;\n    const filePath = pathBrowserify.normalize(pathBrowserify.join(baseUrl, typesPath));\n    \n    // Check if file has been processed\n    if (this.processedFiles.has(filePath)) {\n      return [];\n    }\n    this.processedFiles.add(filePath);\n    \n    try {\n      const response = await fetch(filePath);\n      if (!response.ok) {\n        return [];\n      }\n      \n      const content = await response.text();\n      results.push({\n        content,\n        filePath: this.getFilePath(packageName, typesPath),\n        source: TypeDefinitionSource.BACKEND\n      });\n\n      // Resolve referenced type files\n      await this.resolveReferences(content, packageName, typesPath, results);\n      \n      // Resolve import statements\n      await this.resolveImports(content, packageName, typesPath, results);\n      \n    } catch (error) {\n      console.error(`Error resolving type files for ${packageName}:`, error);\n    }\n\n    return results;\n  }\n\n  /**\n   * Resolve type references in file\n   * @param content File content\n   * @param packageName Package name\n   * @param currentPath Current file path\n   * @param results Results array\n   */\n  private async resolveReferences(\n    content: string,\n    packageName: string,\n    currentPath: string,\n    results: TypeDefinitionResult[]\n  ): Promise<void> {\n    const referenceRegex = /\\/\\/\\/\\s*<reference\\s+path=\"([^\"]+)\"\\s*\\/>/g;\n    const matches = content.matchAll(referenceRegex);\n    const currentDir = pathBrowserify.dirname(currentPath);\n\n    for (const match of matches) {\n      const referencePath = match[1];\n      const baseUrl = `${this.options.baseUrl}/${packageName}`;\n      const relativePath = this.normalizeRelativePath(currentDir, referencePath);\n      const fullPath = pathBrowserify.normalize(pathBrowserify.join(baseUrl, relativePath));\n\n      // Check if file has been processed\n      if (this.processedFiles.has(fullPath)) {\n        continue;\n      }\n      this.processedFiles.add(fullPath);\n\n      try {\n        const response = await fetch(fullPath);\n        if (response.ok) {\n          const referenceContent = await response.text();\n          results.push({\n            content: referenceContent,\n            filePath: this.getFilePath(packageName, relativePath),\n            source: TypeDefinitionSource.REFERENCE\n          });\n\n          // Recursively resolve references in referenced file\n          await this.resolveReferences(referenceContent, packageName, relativePath, results);\n          await this.resolveImports(referenceContent, packageName, relativePath, results);\n        }\n      } catch (error) {\n        console.error(`Error resolving reference ${referencePath}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Resolve import statements in file\n   * @param content File content\n   * @param packageName Package name\n   * @param currentPath Current file path\n   * @param results Results array\n   */\n  private async resolveImports(\n    content: string,\n    packageName: string,\n    currentPath: string,\n    results: TypeDefinitionResult[]\n  ): Promise<void> {\n    const importRegex = /(?:import|export)\\s+(?:{[^}]*}|\\*\\s+as\\s+[^;]+)?\\s*(?:from\\s+)?['\"]([^'\"]+)['\"]/g;\n    const matches = content.matchAll(importRegex);\n    const currentDir = pathBrowserify.dirname(currentPath);\n\n    for (const match of matches) {\n      const importPath = match[1];\n      // Handle relative and package internal paths\n      if (importPath.startsWith('.') || importPath.startsWith(packageName)) {\n        const baseUrl = `${this.options.baseUrl}/${packageName}`;\n        const resolvedPath = importPath.startsWith('.')\n          ? this.normalizeRelativePath(currentDir, importPath)\n          : pathBrowserify.normalize(importPath.replace(packageName, ''));\n        \n        const relativeTypePath = resolvedPath.endsWith('.d.ts') \n          ? resolvedPath \n          : resolvedPath.endsWith('.ts')\n            ? resolvedPath.replace(/\\.ts$/, '.d.ts')\n            : `${resolvedPath}.d.ts`;\n\n        const fullPath = pathBrowserify.normalize(pathBrowserify.join(baseUrl, relativeTypePath));\n\n        // Check if file has been processed\n        if (this.processedFiles.has(fullPath)) {\n          continue;\n        }\n        this.processedFiles.add(fullPath);\n\n        try {\n          const response = await fetch(fullPath);\n          if (response.ok) {\n            const importContent = await response.text();\n            results.push({\n              content: importContent,\n              filePath: this.getFilePath(packageName, relativeTypePath),\n              source: TypeDefinitionSource.IMPORT\n            });\n\n            // Recursively resolve references in imported file\n            await this.resolveReferences(importContent, packageName, relativeTypePath, results);\n            await this.resolveImports(importContent, packageName, relativeTypePath, results);\n          } else {\n            // Try looking in dist/types directory\n            const altPath = pathBrowserify.normalize(pathBrowserify.join(baseUrl, 'dist/types', relativeTypePath));\n            const altResponse = await fetch(altPath);\n            if (altResponse.ok) {\n              const importContent = await altResponse.text();\n              results.push({\n                content: importContent,\n                filePath: this.getFilePath(packageName, `dist/types/${relativeTypePath}`),\n                source: TypeDefinitionSource.IMPORT\n              });\n\n              await this.resolveReferences(importContent, packageName, `dist/types/${relativeTypePath}`, results);\n              await this.resolveImports(importContent, packageName, `dist/types/${relativeTypePath}`, results);\n            }\n          }\n        } catch (error) {\n          console.error(`Error resolving import ${importPath}:`, error);\n        }\n      }\n    }\n  }\n} "],"names":["TypeDefinitionSource","pathBrowserify"],"mappings":"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","x_google_ignoreList":[1]}